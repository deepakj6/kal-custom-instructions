= Kubernetes Domains - Deepdive
:stylesheet: boot-flatly.css
:nofooter:
:data-uri:
:icons: font
:linkattrs:

This lab consists of a list of exercises to demonstrate and understand
the most commonly used kubernetes commands and concepts to ramp up your kubernetes competency skills.



== Learning Outcomes
After completing the lab, you will be able to understand and use Kubernetes concepts based on use-case scenarios in the following domains:

. Core Concepts
. Configuration
. Multi-Container Pods
. Observability
. Pod Design
. Services & Networking
. State Persistence


=== Start the minikube

. Start minikube locally
`minikube start --driver=virtualbox`

. Verify the kubectl context `kubectl config get-contexts` is set to minikube. If not, set it to minikube `kubectl config use-context minikube`

[NOTE]
====
Create all manifest resources in the directory `~/workspace/kubernetes-manifests/competencies`. Watch out for the right file names in the solution section.
====

== Pods 
=== Advanced Configuration & Custom Commands

. Create a busybox pod which prints "Hello from pages Yellow Pages" on the console using manifest file.

+

.Click to see solution
[%collapsible]
====

`~/workspace/kubernetes-manifests/competencies/pods/1.yaml`


[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: busybox
  name: busybox
spec:
  containers:
    - image: busybox
      name: busybox
      command: ["/bin/sh"]
      args: ["-c","echo Hello from pages Yellow Pages"]
------------------
[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pods/1.yaml
------------------
[source, shell script]
------------------
kubectl delete po busybox
------------------
====

. Create a busybox pod which prints "Hello from pages Yellow Pages" on the console, for every 10 seconds infinitely using manifest file.
+
.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pods/2.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: busybox
  name: busybox
spec:
  containers:
    - image: busybox
      name: busybox
      command: ["/bin/sh"]
      args: ["-c","while true;do echo 'Hello from pages Yellow Pages';sleep 10;done"]
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pods/2.yaml
------------------
[source, shell script]
------------------
kubectl logs busybox -f
------------------
[source, shell script]
------------------
kubectl delete po busybox
------------------
====
. Create an nginx pod and test it in the browser  - Instructions
+
.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pods/3.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx

------------------
[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pods/3.yaml

kubectl port-forward pod/nginx 8080:80
------------------
[source, textmate]
------------------
curl localhost:8080   OR
localhost:8080 {from the browser}
------------------
[source, shell script]
------------------
kubectl delete po nginx
------------------
====

. Create a busybox pod which prints "Hello from pages Yellow Pages" on the console imperatively

+
.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
kubectl run busybox --image=busybox  sh -- -c 'echo "Hello from pages Yellow Pages"'
------------------

[source, shell script]
------------------
kubectl delete po busybox
------------------
====

. Create an nginx pod imperatively and test it in the browser or using curl command

+
.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
kubectl run nginx --image=nginx

kubectl port-forward pod/nginx 8080:80
------------------
[source, shell script]
------------------
curl localhost:8080
------------------
[source, shell script]
------------------
kubectl delete po nginx
------------------
====
. Create a busybox pod which prints the `current date` on the console  - Instructions
+
.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pods/6.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: busybox
  name: busybox
spec:
  containers:
    - image: busybox
      name: busybox
      command: ["/bin/sh"]
      args: ["-c","date"]
------------------
====
. Create a busybox pod which prints `current date` on the console, for every 10 seconds infinitely  - Instructions
+
.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pods/7.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: busybox
  name: busybox
spec:
  containers:
    - image: busybox
      name: busybox
      command: ["/bin/sh"]
      args: ["-c","while true;do date;sleep 10;done"]
------------------
====



=== Environment variables:

. Create environment variables for busybox pod with key=`course` and value=`K8s` and also prints "Hello!" on the console, for every 10 seconds infinitely using manifest file.
    Verify the environment variables are set properly

+
.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pods/8.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: busybox
  name: busybox
spec:
  containers:
    - image: busybox
      name: busybox
      command: ["/bin/sh"]
      args: ["-c","while true;do echo 'Hello!';sleep 10;done"]
      env:
        - name: course
          value: k8s
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pods/8.yaml
------------------
[source, shell script]
------------------
kubectl exec -it busybox -- env
------------------
[source, shell script]
------------------
kubectl delete po busybox
------------------
====


. Create environment variables for pages application with key=`PAGE_CONTENT` and value=`Hello from pages environment`
    Verify the environment variables are set properly  - Instructions

+
.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pods/9.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: pages
  name: pages
spec:
  containers:
    - image: [docker-username]/pages:1.0
      name: pages
      env:
        - name: PAGE_CONTENT
          value: Hello from pages environment
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pods/9.yaml
------------------
[source, shell script]
------------------
kubectl exec -it pages -- env
------------------
[source, shell script]
------------------
kubectl delete po pages
------------------
====



=== Probes and Observability:


. Create a simple web server that starts serving traffic after some delay while the application starts up. If we didn't configure our
readiness probe, Kubernetes would either start sending traffic to the container before we're ready, or it would mark the pod as unhealthy and never send it traffic. Use the image `python:2.7-alpine`

. Create a pod that runs a web server. Configure readiness probe within the pod so that Kubernetes sends the
first request after 5 seconds and check if port 80 is accessible. Hint: use nginx image

+
.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pods/10.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    readinessProbe:
      tcpSocket:
        port: 80
      initialDelaySeconds: 5
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pods/10.yaml
------------------
[source, shell script]
------------------
kubectl get po nginx -w
------------------
[source, shell script]
------------------
kubectl delete po nginx
------------------
====

. In the previous scenario add a liveness probe of type exec command to check if index.html exists whose exit code determines the success of the probe every 10 seconds.

+
.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pods/11.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    readinessProbe:
      tcpSocket:
        port: 80
      initialDelaySeconds: 5
    livenessProbe:
      exec:
        command:
          - cat
          - /usr/share/nginx/html/index.html
      periodSeconds: 10
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pods/11.yaml
------------------
[source, shell script]
------------------
kubectl get po nginx -w
------------------
[source, shell script]
------------------
kubectl delete po nginx
------------------
====
. Configure liveness and readiness probe for pages to check if the application is accessible at port 8080 - Instructions

+
.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pods/12.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: pages
  name: pages
spec:
  containers:
  - image: [docker-username]/pages:1.0
    name: pages
    readinessProbe:
      tcpSocket:
        port: 8080
      initialDelaySeconds: 5
    livenessProbe:
      httpGet:
        path: /
        port: 8080
      periodSeconds: 10
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pods/12.yaml
------------------
[source, shell script]
------------------
kubectl get po pages -w
------------------
[source, shell script]
------------------
kubectl delete po pages
------------------
====

== Volumes

. Mount a directory `/var/output` to the container which writes the current date to a file called `log.txt` inside the mounted directory `/var/output` for every `5 seconds`. The directory should reside inside the pod and should cease to exist once the pod terminates.
HINT:: Use `EmptyDir` type of volume


+
.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/volumes/1.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: busybox
  name: busybox-1
spec:
  volumes:
    - name: log-volume
      emptyDir: {}
  containers:
    - image: busybox
      name: busybox-1
      command: ["/bin/sh"]
      args: ["-c","while true; do date > /var/output/log.txt; sleep 5;done"]
      volumeMounts:
        - name: log-volume
          mountPath: /var/output

------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/volumes/1.yaml
------------------
[source, shell script]
------------------
kubectl get po -w
------------------
[source, shell script]
------------------
kubectl exec -it busybox-1 -- cat /var/out/log.txt
------------------

====


. Mount a directory `/var/output` to the container which writes the current date to a file called `log.txt` inside the mounted directory `/var/output` for every `5 seconds`. The directory should reside external to the pod and should exist even if the pod terminates or restarts.
HINT:: Use `HostPath` type of volume


+
.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/volumes/2.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: busybox
  name: busybox-2
spec:
  volumes:
    - name: log-volume
      hostPath:
        path: /var/output
  containers:
    - image: busybox
      name: busybox-2
      command: ["/bin/sh"]
      args: ["-c","while true; do date > /var/output/log.txt; sleep 5;done"]
      volumeMounts:
        - name: log-volume
          mountPath: /var/output

------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/volumes/2.yaml
------------------
[source, shell script]
------------------
kubectl get po -w
------------------
[source, shell script]
------------------
kubectl exec -it busybox-2 -- cat /var/out/log.txt
kubectl delete po busybox-1
kubectl delete po busybox-2
minikube ssh
cat /var/out/log.txt
------------------

====


== SecurityContext
. Create a pod with a container that writes the current date to a file in a mounted volume at /etc/kal-directory/date-file.txt every five seconds. The created file should have the user ID 45 and the group ID 231 which will be useful for auditing and tracking files system updates. Use alpine image.

+
.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pods/13.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: alpine
  name: alpine
spec:
  securityContext:
    runAsUser: 45
    runAsGroup: 231
  volumes:
    - name: log-date-vol
      emptyDir: {}
  containers:
  - image: alpine
    name: alpine
    command: ["/bin/sh"]
    args: ["-c", "while true; do date >> /etc/kal-directory/date-file.txt; sleep 5; done"]
    volumeMounts:
      - name: log-date-vol
        mountPath: /etc/kal-directory
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pods/13.yaml
------------------
[source, shell script]
------------------
kubectl exec -it alpine -- ps
------------------
[source, shell script]
------------------
kubectl exec -it alpine -- cat /etc/kal-directory/date-file.txt
------------------
[source, shell script]
------------------
kubectl delete po alpine
------------------
====

=== Multi-Container Pod Design patterns
. Create a pod that defines an application container which writes the current date to a log file every five seconds. The sidecar container is nginx serving that log file in a shared directory.

+
.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pods/14.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: alpine
  name: alpine
spec:
  volumes:
    - name: log-date-vol
      emptyDir: {}
  containers:
  - image: alpine
    name: alpine
    command: ["/bin/sh"]
    args: ["-c", "while true; do date >> /etc/kal-directory/date-file.txt; sleep 5; done"]
    volumeMounts:
      - name: log-date-vol
        mountPath: /etc/kal-directory
  - image: nginx
    name: nginx
    volumeMounts:
      - name: log-date-vol
        mountPath: /etc/kal-directory
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pods/14.yaml
------------------
[source, shell script]
------------------
kubectl exec -it alpine -c nginx -- cat /etc/kal-directory/date-file.txt
------------------
[source, shell script]
------------------
kubectl delete po alpine
------------------
====


. Create a pod that defines an application container which writes the proccess to a file every five seconds. Create a adapter container that display the top 3 processes consuming maximum memory.

+
HINT: `ps -ao "user,comm,pid,pcpu,pmem,start,time" --sort=pmem`
+
Sample Output

+
[source, textmate]
-------------
USER     COMMAND           PID %CPU %MEM  STARTED     TIME
student  java            16213  2.7  3.7 07:34:42 00:06:47
student  gnome-shell      2373 21.7  1.7   Feb 22 2-04:02:42
student  chrome          14101  1.3  1.1 13:09:55 00:17:56
-------------


+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pods/15.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: multi-container-pod
  name: multi-container-pod
spec:
  volumes:
    - name: shared-vol
      emptyDir: {}
  containers:
    - image: ubuntu
      name: ubuntu
      command: ["/bin/sh"]
      args: ["-c", "while true; do date > /logs/output.txt; free -tw --giga >> /logs/output.txt; sleep 10; done"]
      volumeMounts:
        - name: shared-vol
          mountPath: /logs
    - image: alpine
      name: alpine
      command: ["/bin/sh"]
      args: ["-c", "while true; do echo  'Date: ' $(cat /logs/output.txt |  head -1) > /logs/report.txt; echo 'Total Memory:' $(cat /logs/output.txt |  grep Total: | tr -s ' ' | cut -d ' ' -f 2) GB >> /logs/report.txt; echo 'Free Memory:' $(cat /logs/output.txt |  grep Total: | tr -s ' ' | cut -d ' ' -f 3) GB >> /logs/report.txt; sleep 10; done"]
      volumeMounts:
        - name: shared-vol
          mountPath: /logs
------------------
[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pods/15.yaml
------------------
[source, shell script]
------------------
kubectl get po multi-container-pod
------------------
[source, shell script]
------------------
kubectl exec -it multi-container-pod -c alpine -- cat /logs/report.txt
------------------
[source, shell script]
------------------
kubectl delete po  multi-container-pod
------------------
====

. Create a pod that defines an application container which writes the current date and memory usage to a log file every five seconds. The adapter container will inspect the contents of the app's log file, reformat it, and write the correctly formatted output to a new file

+
HINT: Use the command `free -tw --giga` for printing and choose the appropriate image similar to `ubuntu`

+
Adapter Input Sample

+
[source, textmate]
-------------
Thu Mar 4 11:26:28 GMT 2021
              total        used        free      shared     buffers       cache   available
Mem:             32           9          10           0           0          11          22
Swap:             2           0           2
Total:           34           9          12
-------------

+
Adapter Output Sample

+

[source, textmate]
-------------
Date: Thu Mar  4 09:36:42 GMT 2021
Total Memory: 34GB
Free Memory: 12GB
-------------

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pods/16.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: multi-container-pod
  name: multi-container-pod
spec:
  volumes:
    - name: shared-vol
      emptyDir: {}
  containers:
    - image: ubuntu
      name: ubuntu
      command: ["/bin/sh"]
      args: ["-c", "while true; do date > /logs/output.txt; free -tw --giga >> /logs/output.txt; sleep 10; done"]
      volumeMounts:
        - name: shared-vol
          mountPath: /logs
    - image: alpine
      name: alpine
      command: ["/bin/sh"]
      args: ["-c", "while true; do echo  'Date: ' $(cat /logs/output.txt |  head -1) > /logs/report.txt; echo 'Total Memory:' $(cat /logs/output.txt |  grep Total: | tr -s ' ' | cut -d ' ' -f 2) GB >> /logs/report.txt; echo 'Free Memory:' $(cat /logs/output.txt |  grep Total: | tr -s ' ' | cut -d ' ' -f 3) GB >> /logs/report.txt; sleep 10; done"]
      volumeMounts:
        - name: shared-vol
          mountPath: /logs
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pods/16.yaml
------------------
[source, shell script]
------------------
kubectl get po multi-container-pod
------------------
[source, shell script]
------------------
kubectl exec -it multi-container-pod -c alpine -- cat /logs/report.txt
------------------
[source, shell script]
------------------
kubectl delete po  multi-container-pod
------------------
====

== Pod Design

=== Labels, Selectors and Annotations

. Add a label `tier=service` to the pages application and display the label

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pod-design/1.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: pages
    tier: service
  name: pages
spec:
  containers:
    - image: [docker-username]/pages:1.0
      name: pages
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pod-design/1.yaml
------------------
[source, shell script]
------------------
kubectl get po pages --show-labels
------------------
[source, shell script]
------------------
kubectl delete po pages
------------------
====

. Create a pod nginx and add a label `tier=frontend`

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pod-design/2.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx
    tier: frontend
  name: nginx
spec:
  containers:
    - image: nginx
      name: nginx
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pod-design/2.yaml
------------------
[source, shell script]
------------------
kubectl get po nginx --show-labels
------------------
[source, shell script]
------------------
kubectl delete po nginx
------------------
====

. Get all the pods with label `tier=frontend`

+

.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
kubectl get po -l tier=frontend --show-labels
------------------
====
. Get all the pods which has label tier set to any value

+

.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
kubectl get po -l tier --show-labels
------------------
====

. Annotate nginx pod with annotation `team=yourteam` and `course=k8s`

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pod-design/3.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  annotations:
    team: yourteam
    course: k8s
  labels:
    run: nginx
  name: nginx
spec:
  containers:
    - image: nginx
      name: nginx
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pod-design/3.yaml
------------------
[source, shell script]
------------------
kubectl describe po nginx | grep -i annotations
------------------
[source, shell script]
------------------
kubectl get po nginx -o jsonpath='{.metadata.annotations.course}'
------------------
[source, shell script]
------------------
kubectl get po nginx -o jsonpath='{.metadata.annotations.team}'
------------------
[source, shell script]
------------------
kubectl delete po nginx
------------------
====

=== Deployments

. Create pages deployment with 2 replicas imperatively

+

.Click to see solution
[%collapsible]
====

[source, shell script]
------------------
kubectl create deployment pages --image=[docker-username]/pages:1.0
------------------
[source, shell script]
------------------
kubectl scale deployment pages --replicas=2
------------------
[source, shell script]
------------------
kubectl get deployment pages
------------------
[source, shell script]
------------------
kubectl get po
------------------
[source, shell script]
------------------
kubectl delete deployment pages
------------------
====
. Create pages deployment with 2 replicas using yaml manifest file

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pod-design/4.yaml`
[source, yaml]
------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: pages
  name: pages
spec:
  replicas: 2
  selector:
    matchLabels:
      app: pages
  strategy: {}
  template:
    metadata:
      labels:
        app: pages
    spec:
      containers:
      - image: [docker-username]/pages:1.0
        name: pages
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pod-design/4.yaml
------------------
[source, shell script]
------------------
kubectl get deployment pages
------------------
[source, shell script]
------------------
kubectl get po
------------------
====
. Verify the first version of deployment has been deployed and rolled out

+

.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
kubectl rollout status deployment pages
------------------
====

. Update the manifest to use 3 replicas and image to use the latest version [TODO]. Check the latest version with the instructor.

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pod-design/5.yaml`
[source, yaml]
------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: pages
  name: pages
spec:
  replicas: 3
  selector:
    matchLabels:
      app: pages
  strategy: {}
  template:
    metadata:
      labels:
        app: pages
    spec:
      containers:
      - image: [docker-username]/pages:latest
        name: pages
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pod-design/5.yaml
------------------
[source, shell script]
------------------
kubectl get deployment pages
------------------
[source, shell script]
------------------
kubectl get po
------------------
[source, shell script]
------------------
kubectl delete deploy pages
------------------
====

. Verify the second version of deployment has been deployed and rolled out
+

.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
kubectl rollout status deployment pages
------------------
[source, shell script]
------------------
kubectl rollout history deployment pages
------------------
[source, shell script]
------------------
kubectl rollout history deployment pages --revision=2
------------------
====
. Rollback to the previous version

+

.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
kubectl rollout undo deployment pages
------------------
====
. Manually scale to use 5

+

.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
kubectl scale deployment pages --replicas=5
------------------
====
. Manually scale to use 1 replicas
+

.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
kubectl scale deployment pages --replicas=1
------------------
====

=== Services
. Create a service which routes the request to nginx pod using selectors in the yaml file

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/pod-design/2.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx
    tier: frontend
  name: nginx
spec:
  containers:
    - image: nginx
      name: nginx
------------------
`~/workspace/kubernetes-manifests/competencies/services/1.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Service
metadata:
  labels:
    run: nginx
  name: nginx
spec:
  ports:
  - port: 8080
    protocol: TCP
    targetPort: 80
  selector:
    run: nginx
    tier: frontend
  type: ClusterIP
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/services/1.yaml
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/pod-design/2.yaml
------------------
[source, shell script]
------------------
kubectl get svc nginx -o wide
kubectl get ep
kubectl get po nginx --show-labels
------------------
[source, shell script]
------------------
kubectl port-forward svc/nginx 8080:8080
------------------
[source, shell script]
------------------
curl localhost:8080
------------------
[source, shell script]
------------------
kubectl delete po nginx
------------------
[source, shell script]
------------------
kubectl delete svc nginx
------------------
====

. Create a service (color) of type nodeport and expose port 8080 and target port 80, with the selector app=colorful. Create appropriate nginx pod to be accessible by the service.

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/services/2-pod.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    app: colorful
  name: nginx
spec:
  containers:
    - image: nginx
      name: nginx
------------------
`~/workspace/kubernetes-manifests/competencies/services/2.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Service
metadata:
  labels:
    app: colorful
  name: color
spec:
  ports:
  - port: 8080
    protocol: TCP
    targetPort: 80
  selector:
    app: colorful
  type: NodePort
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/services/2.yaml
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/services/2-pod.yaml
------------------
[source, shell script]
------------------
kubectl get svc color -o wide
kubectl get ep
kubectl get po nginx --show-labels
------------------
[source, shell script]
------------------
kubectl port-forward svc/color 8080:8080
------------------
[source, shell script]
------------------
curl localhost:8080
------------------
[source, shell script]
------------------
kubectl delete po nginx
------------------
[source, shell script]
------------------
kubectl delete svc color
------------------
====
. Create a service named `nginx` of type `NodePort` which routes the traffic to any pod which has the label `app=colorful` exposing target port `80` on port `80`.
  The service  does not route traffic to any pods yet. We shall use it in later exercises.

+

.Click to see solution
[%collapsible]
====

[source, shell script]
------------------
cd ~/workspace/kubernetes-manifests/competencies/services
mkdir green
cd green

------------------

`~/workspace/kubernetes-manifests/competencies/services/green/service.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Service
metadata:
  labels:
    app: colorful
  name: nginx
spec:
  type: NodePort
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: colorful
------------------
[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/services/green/service.yaml

kubectl get svc nginx
kubectl get ep
------------------

====

. Create a `nginx-green` pod deriving from `nginx` image, which prints a custom message `Green` (HINT::  echo Green > /usr/share/nginx/html/index.html) instead of its original message, having the label `app=colorful` & Create a `nginx-blue` pod deriving from `nginx` image, which prints a custom message `Blue` (HINT:: echo Blue > /usr/share/nginx/html/index.html) instead of its original message having the label `app=colorful`
Make multiple requests to the `nginx` service created in the previous exercise and ensure that the service is routing requests between the two different pods.
Delete the pods and services before moving on to the next exercise.

+

.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
cd ~/workspace/kubernetes-manifests/competencies/services/green
------------------

`~/workspace/kubernetes-manifests/competencies/services/green/Dockerfile`
[source,java]
------------------
FROM nginx:latest
RUN echo Green > /usr/share/nginx/html/index.html
------------------

[source, shell script]
------------------
docker build -t [docker-username]/nginx:green .
docker push [docker-username]/nginx:green
------------------


[source, shell script]
------------------
cd ~/workspace/kubernetes-manifests/competencies/services/blue
------------------

`~/workspace/kubernetes-manifests/competencies/services/blue/Dockerfile`
[source, java]
------------------
FROM nginx:latest
RUN echo Blue > /usr/share/nginx/html/index.html
------------------

[source, shell script]
------------------
docker build -t [docker-username]/nginx:blue .
docker push [docker-username]/nginx:blue
------------------


`~/workspace/kubernetes-manifests/competencies/services/green/pod.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    app: colorful
  name: nginx-green
spec:
  containers:
  - image: [docker-username]/nginx:green
    name: nginx-green
------------------


`~/workspace/kubernetes-manifests/competencies/services/blue/pod.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    app: colorful
  name: nginx-blue
spec:
  containers:
  - image: [docker-username]/nginx:blue
    name: nginx-blue
------------------


[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/services/green/pod.yaml
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/services/blue/pod.yaml

kubectl get all
------------------

[source, shell script]
------------------
kubectl get svc nginx
------------------
**Copy the 5 digit NODEPORT under the column PORT(S)**

[source, shell script]
------------------
kubectl get nodes -o wide
------------------
**Copy the INTERNAL-IP **

[source, shell script]
------------------
curl http://INTERNAL-IP:NODEPORT
**Run the command for a few times to understand the concept of kubernetes service discovery**
------------------
**Clean up **
[source, shell script]
------------------
kubectl delete po -l app=colorful
kubectl delete svc -l app=colorful
------------------
====

. Create 2 deployments of the nginx application from the previous exercise. The first deployment is `nginx-blue` application, scaled to 3 replicas, and the second deployment is a single replica of `nginx-green` application.
Create the service, which will forward network requests to any pod with the label `app=colorful`
+
.Click to see solution
[%collapsible]
====

[source, shell script]
------------------
cd ~/workspace/kubernetes-manifests/competencies/services/green
------------------

`~/workspace/kubernetes-manifests/competencies/services/green/deployment.yaml`
[source, yaml]
------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: colorful
  name: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: colorful
  template:
    metadata:
      labels:
        app: colorful
    spec:
      containers:
      - image: [docker-username]/nginx:green
        name: nginx
------------------
`~/workspace/kubernetes-manifests/competencies/services/blue/deployment.yaml`
[source, yaml]
------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: colorful
  name: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: colorful
  template:
    metadata:
      labels:
        app: colorful
    spec:
      containers:
      - image: [docker-username]/nginx:green
        name: nginx
------------------
[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/services/green/deployment.yaml
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/services/blue/deployment.yaml
------------------

**Let's reuse the service created in the previous exercise as it serves our purpose**
[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/services/green/service.yaml
------------------

[source, shell script]
------------------
kubectl get all --show-labels
kubectl get svc nginx
------------------
**Copy the 5 digit NODEPORT under the column PORT(S)**

[source, shell script]
------------------
kubectl get nodes -o wide
------------------
**Copy the INTERNAL-IP **

[source, shell script]
------------------
curl http://INTERNAL-IP:NODEPORT
------------------
**Run the command few times and watch how the Kubernetes service automatically load balances our request between the running pods**
====

=== Persistent Volumes

. Create a Persistent Volume which is used as a long term storage solution. Create a Persistent Volume Claim to use the persistent volume. Create a pod that defines an application container which writes the current date to a log file every five seconds and this pod will eventually use persistent volume claim when mounting the log file to persistent volume.

+

.Click to see solution
[%collapsible]
====

`~/workspace/kubernetes-manifests/competencies/volumes/pv-1.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: PersistentVolume
metadata:
  name: log-pv-[student-name]
  labels:
    type: local
spec:
  storageClassName: document
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: "/etc/kal-directory"
------------------
`~/workspace/kubernetes-manifests/competencies/volumes/pvc-1.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: log-pvc-[student-name]
spec:
  storageClassName: document
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 1Gi
------------------

`~/workspace/kubernetes-manifests/competencies/volumes/pod-1.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: alpine
  name: alpine
spec:
  volumes:
    - name: log-date-vol
      persistentVolumeClaim:
            claimName: log-pvc-[student-name]
  containers:
  - image: alpine
    name: alpine
    command: ["/bin/sh"]
    args: ["-c", "while true; do date >> /etc/kal-directory/date-file.txt; sleep 5; done"]
    volumeMounts:
      - name: log-date-vol
        mountPath: /etc/kal-directory
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/volumes/pv-1.yaml
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/volumes/pvc-1.yaml
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/volumes/pod-1.yaml
------------------
[source, shell script]
------------------
kubectl get po alpine
------------------
[source, shell script]
------------------
kubectl exec -it alpine -- cat /etc/kal-directory/date-file.txt
------------------
[source, shell script]
------------------
kubectl delete po alpine
kubectl delete pvc log-pvc-[student-name]
kubectl delete pv log-pv-[student-name]
------------------
====

. Re-design the pod that was created in  Multicontainer section: Exercise 2, such that the written files will be mounted on Persistent Volume.
Create required Persistent Volume and Persistent Volume Claim. Storage capacity of Persistent Volume shoud not exceed 500M

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/volumes/pod-2.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: multi-container-pod
  name: multi-container-pod
spec:
  volumes:
    - name: shared-vol
      emptyDir: {}
  containers:
    - image: ubuntu
      name: ubuntu
      command: ["/bin/sh"]
      args: ["-c", "while true; do date > /logs/output.txt; free -tw --giga >> /logs/output.txt; sleep 10; done"]
      volumeMounts:
        - name: shared-vol
          mountPath: /logs
    - image: alpine
      name: alpine
      command: ["/bin/sh"]
      args: ["-c", "while true; do echo  'Date: ' $(cat /logs/output.txt |  head -1) > /logs/report.txt; echo 'Total Memory:' $(cat /logs/output.txt |  grep Total: | tr -s ' ' | cut -d ' ' -f 2) GB >> /logs/report.txt; echo 'Free Memory:' $(cat /logs/output.txt |  grep Total: | tr -s ' ' | cut -d ' ' -f 3) GB >> /logs/report.txt; sleep 10; done"]
      volumeMounts:
        - name: shared-vol
          mountPath: /logs
------------------
[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/volumes/pod-2.yaml
------------------
[source, shell script]
------------------
kubectl get po multi-container-pod
------------------
[source, shell script]
------------------
kubectl exec -it multi-container-pod -c alpine -- cat /logs/report.txt
------------------
[source, shell script]
------------------
kubectl delete po  multi-container-pod
------------------
====

=== Configmaps and Secrets

. Create a ConfigMap course-config from literal values with key='course' and value='k8s' imperatively. Create environment variables for nginx pod with key=`course` and value to be read from the configmap.
Hint: `configMapKeyRef`

+

.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
kubectl create configmap course-config --from-literal=course=k8s
------------------

`~/workspace/kubernetes-manifests/competencies/configuration/pod-1.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    env:
      - name: course
        valueFrom:
          configMapKeyRef:
            name: course-config
            key: course
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/pod-1.yaml
------------------
[source, shell script]
------------------
kubectl get cm course-config
------------------
[source, shell script]
------------------
kubectl get po nginx
kubectl exec -it nginx -- env
------------------
[source, shell script]
------------------
kubectl delete po nginx
------------------
====
. Create the above ConfigMap using yaml. Create a nginx pod and read the environment variables key and value from ConfigMap
Hint: `configMapRef`

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/configuration/cm-2.yaml`
[source, yaml]
------------------
apiVersion: v1
data:
  course: k8s
kind: ConfigMap
metadata:
  name: course-config
------------------

`~/workspace/kubernetes-manifests/competencies/configuration/pod-1.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    env:
      - name: course
        valueFrom:
          configMapKeyRef:
            name: course-config
            key: course
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/cm-2.yaml
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/pod-1.yaml
------------------
[source, shell script]
------------------
kubectl get cm course-config
------------------
[source, shell script]
------------------
kubectl get po nginx
kubectl exec -it nginx -- env
------------------
[source, shell script]
------------------
kubectl delete po nginx
------------------
====

. Create a ConfigMap `pages-config` from literal values with key='PAGE_CONTENT' and value='Hello from pages environment' imperatively. Create environment variables for pages aplication with key=`PAGE_CONTENT` and value to be read from the configmap. - Instructions

+

.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
kubectl create configmap pages-config --from-literal=PAGE_CONTENT="Hello from pages environment"
------------------

`~/workspace/kubernetes-manifests/competencies/configuration/pod-3.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: pages
  name: pages
spec:
  containers:
  - image: [docker-username]/pages:1.0
    name: pages
    env:
      - name: PAGE_CONTENT
        valueFrom:
          configMapKeyRef:
            name: pages-config
            key: PAGE_CONTENT
------------------
[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/pod-3.yaml
------------------
[source, shell script]
------------------
kubectl get cm pages-config
------------------
[source, shell script]
------------------
kubectl get po pages
kubectl exec -it pages -- env
------------------
[source, shell script]
------------------
kubectl delete po pages
------------------
====
. Create the above ConfigMap using yaml. Create a nginx pod and read the environment variables key and value from ConfigMap. - Instructions

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/configuration/cm-4.yaml`
[source, yaml]
------------------
apiVersion: v1
data:
  PAGE_CONTENT: Hello from pages environment
kind: ConfigMap
metadata:
  name: pages-config
------------------

`~/workspace/kubernetes-manifests/competencies/configuration/pod-4.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: pages
  name: pages
spec:
  containers:
  - image: [docker-username]/pages:1.0
    name: pages
    env:
      - name: PAGE_CONTENT
        valueFrom:
          configMapKeyRef:
            name: pages-config
            key: PAGE_CONTENT
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/cm-4.yaml
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/pod-4.yaml
------------------
[source, shell script]
------------------
kubectl get cm pages-config
------------------
[source, shell script]
------------------
kubectl get po pages
kubectl exec -it pages -- env
------------------
[source, shell script]
------------------
kubectl delete po pages
------------------
====

. Create a ConfigMap from a properties file with key='course' and value='k8s'. Create a nginx pod and mount the configmap as a volume.

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/configuration/cm-5.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: ConfigMap
metadata:
  name: course-config
data:
  course-info.properties: |
    course: k8s
------------------

`~/workspace/kubernetes-manifests/competencies/configuration/pod-5.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx
  name: nginx
spec:
  volumes:
    - name: config-vol
      configMap:
        name: course-config
  containers:
  - image: nginx
    name: nginx
    volumeMounts:
      - name: config-vol
        mountPath: /etc/config
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/cm-5.yaml
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/pod-5.yaml
------------------
[source, shell script]
------------------
kubectl get cm course-config
------------------
[source, shell script]
------------------
kubectl get po nginx
kubectl exec -it nginx -- ls /etc/config
kubectl exec -it nginx -- cat /etc/config/course-info.properties
------------------
[source, shell script]
------------------
kubectl delete po nginx
------------------
====

. Create a configMap from application.properties used by Pages application. Mount this configmap as a volume while creating pod for pages application - Instructions

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/configuration/cm-6.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: ConfigMap
metadata:
  name: pages-config
data:
  application.properties: |
    PAGE_CONTENT: Hello from pages environment
------------------

`~/workspace/kubernetes-manifests/competencies/configuration/pod-6.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: pages
  name: pages
spec:
  volumes:
    - name: config-vol
      configMap:
        name: pages-config
  containers:
  - image: [docker-username]/pages:1.0
    name: pages
    volumeMounts:
      - name: config-vol
        mountPath: /etc/config
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/cm-6.yaml
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/pod-6.yaml
------------------
[source, shell script]
------------------
kubectl get cm pages-config
------------------
[source, shell script]
------------------
kubectl get po pages
kubectl exec -it pages -- ls /etc/config
kubectl exec -it pages -- cat /etc/config/application.properties
------------------
[source, shell script]
------------------
kubectl delete po pages
------------------
====

. Create a secret `course-secret` from literal value with key='auth-token' and value=base 64 encoded value of 'token-e8ujdekdjueke' imperatively. Create environment variable for nginx pod with key='auth-token' and value to be read from the secret.
Hint: `secretMapKeyRef`

+

.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
kubectl create secret generic course-secret --from-literal=auth-token=token-e8ujdekdjueke
kubectl get secret course-secret
------------------

`~/workspace/kubernetes-manifests/competencies/configuration/pod-7.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    env:
      - name: auth-token
        valueFrom:
          secretKeyRef:
            name: course-secret
            key: auth-token
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/pod-7.yaml
------------------
[source, shell script]
------------------
kubectl get po nginx
kubectl exec -it nginx -- env
------------------
[source, shell script]
------------------
kubectl delete po nginx
------------------
====

. Create a secret `course-secret` from literal value with key='auth-token' and value=base 64 encoded value of 'token-e8ujdekdjueke' using manifest files. Create environment variable for nginx pod with key='auth-token' and value to be read from the secret.
Hint: `secretMapKeyRef`

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/configuration/secret-8.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Secret
metadata:
  name: course-secret
data:
  auth-token: dG9rZW4tZTh1amRla2RqdWVrZQ==
------------------

`~/workspace/kubernetes-manifests/competencies/configuration/pod-8.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    env:
      - name: auth-token
        valueFrom:
          secretKeyRef:
            name: course-secret
            key: auth-token
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/secret-8.yaml
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/pod-8.yaml
------------------
[source, shell script]
------------------
kubectl get secret course-secret
------------------
[source, shell script]
------------------
kubectl get po nginx
kubectl exec -it nginx -- env
------------------
[source, shell script]
------------------
kubectl delete po nginx
------------------
====

. Create a secret `pages-secret` from literal values with key='password' and value=base 64 encoded value of 'admin@123' imperatively. Create environment for Pages application with key='password' and value to be read from the secret. - Instructions

+

.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
kubectl create secret generic pages-secret --from-literal=password=admin@123
kubectl get secret pages-secret
------------------

`~/workspace/kubernetes-manifests/competencies/configuration/pod-9.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: pages
  name: pages
spec:
  containers:
  - image: [docker-username]/pages:1.0
    name: pages
    env:
      - name: password
        valueFrom:
          secretKeyRef:
            name: pages-secret
            key: password
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/pod-9.yaml
------------------
[source, shell script]
------------------
kubectl get po pages
kubectl exec -it pages -- env
------------------
[source, shell script]
------------------
kubectl delete po pages
------------------
====

. Create a secret `pages-secret` from literal values with key='password' and value=base 64 encoded value of 'admin@123' using manifest files. Create environment for Pages application with key='password' and value to be read from the secret. - Instructions

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/configuration/secret-10.yaml`
[source, yaml]
------------------
apiVersion: v1
data:
  password: YWRtaW5AMTIz
kind: Secret
metadata:
  name: pages-secret
------------------

`~/workspace/kubernetes-manifests/competencies/configuration/pod-10.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: pages
  name: pages
spec:
  containers:
  - image: [docker-username]/pages:1.0
    name: pages
    env:
      - name: password
        valueFrom:
          secretKeyRef:
            name: pages-secret
            key: password
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/secret-10.yaml
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/pod-10.yaml
------------------
[source, shell script]
------------------
kubectl get po pages
kubectl exec -it pages -- env
------------------
[source, shell script]
------------------
kubectl delete po pages
------------------
====


. Create the above secret from a properties file with key='password' and value=base 64 encoded value of 'admin@123'. Mount this secret as a volume while creating an nginx pod. - Instructions

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/configuration/secret-11.yaml`
[source, yaml]
------------------
apiVersion: v1
data:
  application.properties: cGFzc3dvcmQ9YWRtaW5AMTIzCg==
kind: Secret
metadata:
  name: pages-secret
------------------

`~/workspace/kubernetes-manifests/competencies/configuration/pod-11.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: pages
  name: pages
spec:
  volumes:
    - name: secret-vol
      secret:
        secretName: pages-secret
  containers:
  - image: [docker-username]/pages:1.0
    name: pages
    volumeMounts:
      - name: secret-vol
        mountPath: /etc/config
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/secret-11.yaml
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/configuration/pod-11.yaml
------------------
[source, shell script]
------------------
kubectl get secret pages-secret
kubectl get po pages
kubectl exec -it pages -- cat /etc/config/application.properties
------------------
[source, shell script]
------------------
kubectl delete po pages
------------------
====

=== Jobs and CronJobs

. Create a job to print current date and time

+

.Click to see solution
[%collapsible]
====

`~/workspace/kubernetes-manifests/competencies/jobs/job-1.yaml`
[source, yaml]
------------------
apiVersion: batch/v1
kind: Job
metadata:
  labels:
    run: busybox
  name: busybox
spec:
  template:
    spec:
      containers:
      - image: busybox
        name: busybox
        command: ["/bin/sh"]
        args: ["-c","date"]
      restartPolicy: OnFailure
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/jobs/job-1.yaml
kubectl get job busybox
kubectl get pods
kubectl logs <job-pod-name>
------------------
[source, shell script]
------------------
kubectl delete job busybox
------------------
====

. Create a job to calculate the value of pi upto 1000 digits and print the output in command line. Use Perl to calculate.

+

.Click to see solution
[%collapsible]
====

`~/workspace/kubernetes-manifests/competencies/jobs/job-2.yaml`
[source, yaml]
------------------
apiVersion: batch/v1
kind: Job
metadata:
  labels:
    run: perl
  name: perl
spec:
  template:
    spec:
      containers:
      - image: perl
        name: perl
        command: ["perl","-Mbignum=bpi", "-wle", "print bpi(1000)"]
      restartPolicy: Never
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/jobs/job-2.yaml
kubectl get job perl
kubectl get pods
kubectl logs <job-pod-name>
------------------
[source, shell script]
------------------
kubectl delete job perl
------------------
====

. Create a job which runs a workload which simulates rolling the dice and returns a zero exit code (i.e. success) when you get a six.

+

.Click to see solution
[%collapsible]
====

`~/workspace/kubernetes-manifests/competencies/jobs/job-3.yaml`
[source, yaml]
------------------
kind: Job
apiVersion: batch/v1
metadata:
  name: job-3
spec:
  completions: 1
  parallelism: 1
  template:
    metadata:
      name: job-3
    spec:
      restartPolicy: Never
      containers:
        - name: job-3
          image: alpine
          command: ["/bin/sh"]
          args: ["-c", "if [ \"$(shuf -i 1-6 -n 1)\" = \"6\" ]; then exit 0; else exit 1; fi"]
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/jobs/job-3.yaml
kubectl get job job-3
------------------
[source, shell script]
------------------
kubectl delete job job-3
------------------
====

. Create a CronJob that will ping Github every minute and check that their site hasn't gone down. You can use alpine image.

+

`image: busybox`

+ 

`command: ["/bin/sh"]`
+
`args: ["-c", "ping -w 1 github.com"]`

+

.Click to see solution
[%collapsible]
====

`~/workspace/kubernetes-manifests/competencies/jobs/job-4.yaml`
[source, yaml]
------------------
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: job-4
spec:
  jobTemplate:
    metadata:
      name: job-4
    spec:
      template:
        metadata:
        spec:
          containers:
          - image: busybox
            name: job-4
            command: ["/bin/sh"]
            args: ["-c", "ping -w 1 github.com"]
          restartPolicy: OnFailure
  schedule: '*/1 * * * *'
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/jobs/job-4.yaml
kubectl get cronjob job-4
kubectl get pods
------------------
[source, shell script]
------------------
kubectl logs <pod-name>
------------------
[source, shell script]
------------------
kubectl delete cronjob job-4
------------------
====

. Create a cron job to print current date and time every minute

+

.Click to see solution
[%collapsible]
====

`~/workspace/kubernetes-manifests/competencies/jobs/job-5.yaml`
[source, yaml]
------------------
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: job-5
spec:
  jobTemplate:
    metadata:
      name: job-5
    spec:
      template:
        metadata:
        spec:
          containers:
          - image: busybox
            name: job-5
            command: ["/bin/sh"]
            args: ["-c","date"]
          restartPolicy: OnFailure
  schedule: '*/1 * * * *'
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/jobs/job-5.yaml
kubectl get cronjob job-5
kubectl get pods
------------------
[source, shell script]
------------------
kubectl logs <pod-name>
------------------
[source, shell script]
------------------
kubectl delete cronjob job-5
------------------
====

. Create a cron job to print "Time: 3.30 pm. It is break time. Lets stretch out a bit or have a coffee!" at 3.30pm today

+

.Click to see solution
[%collapsible]
====

`~/workspace/kubernetes-manifests/competencies/jobs/job-6.yaml`
[source, yaml]
------------------
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: job-6
spec:
  jobTemplate:
    metadata:
      name: job-6
    spec:
      template:
        metadata:
        spec:
          volumes:
            - name: tz-config
              hostPath:
                path: /usr/share/zoneinfo/Europe/Moscow
          containers:
          - image: busybox
            name: job-6
            command: ["/bin/sh"]
            args: ["-c","Time: 3.30 pm. It is break time. Lets stretch out a bit or have a coffee!"]
            volumeMounts:
              - name: tz-config
                mountPath: /etc/localtime
          restartPolicy: OnFailure
  schedule: '30 15 * * *'
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/jobs/job-6.yaml
kubectl get cj job-6
kubectl get pods
------------------
[source, shell script]
------------------
kubectl logs <pod-name>
------------------
[source, shell script]
------------------
kubectl delete cronjob job-6
------------------
====

=== Namespaces & ResourceQuotas

. Create a namespace called alpha imperatively

+

.Click to see solution
[%collapsible]
====

[source, shell script]
------------------
kubectl create namespace alpha
------------------

[source, shell script]
------------------
kubectl delete namespace alpha
------------------
====


. Create a namespace called angel declaratively

+

.Click to see solution
[%collapsible]
====
`~/workspace/kubernetes-manifests/competencies/namespace/ns-1.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: Namespace
metadata:
  name: angel
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/namespace/ns-1.yaml
kubectl get ns
------------------

[source, shell script]
------------------
kubectl delete ns angel
------------------
====

. Create a resource quota in the namespace alpha with the below requirement. After creating the quota, Create an nginx pod within alpha and should you get an error, try to troubleshoot and solve it

+
[source, yaml]
-------------
pods:5    
"requests.cpu": "2"
"requests.memory": 1024m
"limits.cpu": "4"
"limits.memory": 2048m
-------------

+

.Click to see solution
[%collapsible]
====

`~/workspace/kubernetes-manifests/competencies/resource-quota.yaml`
[source, yaml]
------------------
apiVersion: v1
kind: ResourceQuota
metadata:
  name: resource-quota
  namespace: [student-name]
spec:
  hard:
    cpu: 2
    memory: 2Gi
    pods: 5
------------------

[source, shell script]
------------------
kubectl apply -f ~/workspace/kubernetes-manifests/competencies/resource-quota.yaml
kubectl get resourcequota
------------------

[source, shell script]
------------------
kubectl delete rs resource-quota
------------------
====

=== ServiceAccount

. Create a secret called `docker-registry` of type `generic` in the namespace that you are currently working in.
  Use this secret to apply to all the pods in such a way that these credentials will be used by kubernetes while pulling images from dockerhub.
  One way to do that is by means of a patch operation updating the service account for the corresponding namespace.


+

.Click to see solution
[%collapsible]
====
[source, shell script]
------------------
docker logout
docker login
------------------

[source, shell script]
------------------
cp ~/.docker/config.json config.json
kubectl create secret generic docker-registry \
    --from-file=.dockerconfigjson=config.json \
    --type=kubernetes.io/dockerconfigjson -n default
------------------

[source, shell script]
------------------
kubectl get serviceaccount default -o yaml -n default
kubectl patch serviceaccount default -p '{"imagePullSecrets": [{"name": "docker-registry"}]}' -n default
kubectl get serviceaccount default -o yaml -n default
rm config.json
------------------
====